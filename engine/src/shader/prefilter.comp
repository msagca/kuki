#version 460 core
const float EPSILON = 1.0e-6;
const float PI = 3.14159265359;
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba32f, binding = 0) writeonly uniform imageCube prefilteredMap;
uniform float roughness;
uniform samplerCube cubeMap;
uniform uint cubeSize;
uniform uint mipLevels;
uniform uint mipWidth;
float DistributionGGX(vec3, vec3, float);
float RadicalInverseVdC(uint);
vec2 Hammersley(uint, uint);
vec3 CubeDirectionFromCoord(ivec3, uint);
vec3 ImportanceSampleGGX(vec2, vec3, float);
void main() {
        ivec3 gid = ivec3(gl_GlobalInvocationID);
        if (gid.x >= cubeSize || gid.y >= cubeSize || gid.z >= 6) return;
        vec3 N = CubeDirectionFromCoord(gid, cubeSize);
        vec3 R = N;
        vec3 V = R;
        vec3 prefilteredColor = vec3(0.0);
        float totalWeight = 0.0;
        uint sampleCount = uint(mix(1024.0, 4096.0, roughness * roughness));
        for (uint i = 0u; i < sampleCount; ++i) {
                vec2 Xi = Hammersley(i, sampleCount);
                vec3 H = ImportanceSampleGGX(Xi, N, roughness);
                vec3 L = normalize(2.0 * dot(V, H) * H - V);
                float NdotL = max(dot(N, L), 0.0);
                if (NdotL > 0.0) {
                        float D = DistributionGGX(N, H, roughness);
                        float NdotH = max(dot(N, H), 0.0);
                        float HdotV = max(dot(H, V), 0.0);
                        float pdf = D * NdotH / (4.0 * HdotV) + EPSILON;
                        float saTexel = 4.0 * PI / (6.0 * mipWidth * mipWidth);
                        float saSample = 1.0 / (float(sampleCount) * pdf + EPSILON);
                        float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel);
                        mipLevel = clamp(mipLevel, 0.0, float(mipLevels - 1));
                        prefilteredColor += textureLod(cubeMap, L, mipLevel).rgb * NdotL;
                        totalWeight += NdotL;
                }
        }
        prefilteredColor /= totalWeight;
        imageStore(prefilteredMap, gid, vec4(prefilteredColor, 1.0));
}
vec3 CubeDirectionFromCoord(ivec3 coord, uint cubeSize) {
        uint face = coord.z;
        float u = (float(coord.x) + 0.5) / float(cubeSize);
        float v = (float(coord.y) + 0.5) / float(cubeSize);
        float s = 2.0 * u - 1.0;
        float t = 2.0 * v - 1.0;
        vec3 dir;
        switch (face) {
                case 0:
                dir = vec3(1.0, -t, -s);
                break; // +x
                case 1:
                dir = vec3(-1.0, -t, s);
                break; // -x
                case 2:
                dir = vec3(s, 1.0, t);
                break; // +y
                case 3:
                dir = vec3(s, -1.0, -t);
                break; // -y
                case 4:
                dir = vec3(s, -t, 1.0);
                break; // +z
                case 5:
                dir = vec3(-s, -t, -1.0);
                break; // -z
        }
        return normalize(dir);
}
float DistributionGGX(vec3 N, vec3 H, float roughness) {
        float a = roughness * roughness;
        float a2 = a * a;
        float NdotH = max(dot(N, H), 0.0);
        float NdotH2 = NdotH * NdotH;
        float denom = (NdotH2 * (a2 - 1.0) + 1.0);
        denom = PI * denom * denom;
        return a2 / denom;
}
vec2 Hammersley(uint i, uint N) {
        return vec2(float(i) / float(N), RadicalInverseVdC(i));
}
vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {
        float a = roughness * roughness;
        float phi = 2.0 * PI * Xi.x;
        float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
        float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
        vec3 H;
        H.x = cos(phi) * sinTheta;
        H.y = sin(phi) * sinTheta;
        H.z = cosTheta;
        vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
        vec3 tangent = normalize(cross(up, N));
        vec3 bitangent = cross(N, tangent);
        vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;
        return normalize(sampleVec);
}
float RadicalInverseVdC(uint bits) {
        bits = (bits << 16u) | (bits >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        return float(bits) * 2.3283064365386963e-10;
}
